@startuml Sequence Diagram - Komunikacja miÄ™dzy UÅ¼ytkownikami

title Diagram PrzepÅ‚ywu Sterowania\nScenariusz: Komunikacja KupujÄ…cy - Sprzedawca (WebSocket)

actor "KupujÄ…cy" as Buyer
participant "Browser\n(KupujÄ…cy)" as UI_B
participant "WebSocket\nClient" as WS_B
participant "WebSocket\nServer" as WSS
participant "ChatController" as Controller
participant "ChatService" as Service
participant "MessageRepository" as RepoMsg
participant "ConversationRepository" as RepoConv
participant "UserRepository" as RepoUser
participant "Database" as DB
participant "WebSocket\nClient" as WS_S
participant "Browser\n(Sprzedawca)" as UI_S
actor "Sprzedawca" as Seller

== Faza 1: Inicjalizacja PoÅ‚Ä…czenia ==

Buyer -> UI_B: Otwiera stronÄ™ aukcji
UI_B -> UI_B: Pobiera aukcjÄ™ z API
UI_B -> Buyer: WyÅ›wietla szczegÃ³Å‚y\n+ przycisk "Kontakt"

Buyer -> UI_B: Klika "WyÅ›lij wiadomoÅ›Ä‡"
UI_B -> WS_B: NawiÄ…zuje poÅ‚Ä…czenie WebSocket
WS_B -> WSS: CONNECT /ws\nAuthorization: Bearer {JWT}
WSS -> WSS: Weryfikuje token JWT
WSS --> WS_B: Connection established
WS_B --> UI_B: âœ“ PoÅ‚Ä…czono

note right of Buyer
  WebSocket pozwala na
  komunikacjÄ™ real-time
  bez odÅ›wieÅ¼ania strony
end note

== RÃ³wnolegle: Sprzedawca teÅ¼ siÄ™ Å‚Ä…czy ==

Seller -> UI_S: Sprawdza wiadomoÅ›ci
UI_S -> WS_S: NawiÄ…zuje poÅ‚Ä…czenie WebSocket
WS_S -> WSS: CONNECT /ws\nAuthorization: Bearer {JWT}
WSS --> WS_S: Connection established

== Faza 2: WysÅ‚anie Pierwszej WiadomoÅ›ci ==

Buyer -> UI_B: Pisze wiadomoÅ›Ä‡:\n"Czy auto jest dostÄ™pne?"

UI_B -> Controller: POST /api/messages/send
note right
  MessageRequestDto:
  - recipientId (ID sprzedawcy)
  - productId (ID aukcji)
  - content (treÅ›Ä‡)
end note

activate Controller
Controller -> Service: sendMessage(senderId, recipientId,\nproductId, content)

activate Service
Service -> RepoUser: findById(senderId)
RepoUser -> DB: SELECT * FROM users WHERE id = ?
DB --> RepoUser: UserEntity (kupujÄ…cy)
RepoUser --> Service: sender

Service -> RepoUser: findById(recipientId)
RepoUser -> DB: SELECT * FROM users WHERE id = ?
DB --> RepoUser: UserEntity (sprzedawca)
RepoUser --> Service: recipient

Service -> RepoConv: findConversationBetween\nUsers(senderId, recipientId, productId)
RepoConv -> DB: SELECT * FROM conversations...

alt Konwersacja istnieje
    DB --> RepoConv: ConversationEntity
    RepoConv --> Service: conversation
else Nowa konwersacja
    DB --> RepoConv: null
    RepoConv --> Service: null
    Service -> Service: Tworzy nowÄ… ConversationEntity
    Service -> RepoConv: save(conversation)
    RepoConv -> DB: INSERT INTO conversations
    DB --> RepoConv: Saved conversation
    RepoConv --> Service: conversation
end

Service -> Service: Tworzy MessageEntity:\n- sender, recipient\n- conversation\n- content\n- timestamp\n- isRead = false

Service -> RepoMsg: save(message)
RepoMsg -> DB: INSERT INTO messages
DB --> RepoMsg: Saved MessageEntity
RepoMsg --> Service: message

Service --> Controller: MessageEntity
deactivate Service
Controller --> UI_B: 200 OK {message}
deactivate Controller

UI_B -> UI_B: Dodaje wiadomoÅ›Ä‡ do UI

== Faza 3: WysyÅ‚ka przez WebSocket ==

UI_B -> WS_B: WysyÅ‚a przez WebSocket
WS_B -> WSS: SEND message\nto /app/chat.send

activate WSS
WSS -> WSS: Identyfikuje odbiorcÄ™\n(recipientId ze sprzedawcy)

WSS -> WS_S: BROADCAST do sprzedawcy\n/topic/messages/{userId}
deactivate WSS

WS_S -> UI_S: Odbiera nowÄ… wiadomoÅ›Ä‡
UI_S -> UI_S: WyÅ›wietla powiadomienie
UI_S -> UI_S: Odtwarza dÅºwiÄ™k (opcjonalnie)
UI_S -> Seller: ğŸ”” "Nowa wiadomoÅ›Ä‡ od {username}"

== Faza 4: OdpowiedÅº Sprzedawcy ==

Seller -> UI_S: Pisze odpowiedÅº:\n"Tak, auto dostÄ™pne. Tel: 123-456-789"

UI_S -> Controller: POST /api/messages/send
Controller -> Service: sendMessage(sellerId, buyerId,\nproductId, content)

Service -> Service: Proces analogiczny\njak wczeÅ›niej...

Service -> RepoMsg: save(replyMessage)
RepoMsg -> DB: INSERT INTO messages
DB --> RepoMsg: Saved message
RepoMsg --> Service: replyMessage

Service --> Controller: MessageEntity
Controller --> UI_S: 200 OK

UI_S -> WS_S: WysyÅ‚a przez WebSocket
WS_S -> WSS: SEND to /app/chat.send
WSS -> WS_B: BROADCAST do kupujÄ…cego
WS_B -> UI_B: Odbiera odpowiedÅº
UI_B -> Buyer: ğŸ”” "Nowa odpowiedÅº od sprzedawcy"

== Faza 5: Oznaczenie jako Przeczytane ==

Buyer -> UI_B: Otwiera rozmowÄ™
UI_B -> Controller: PATCH /api/messages/{msgId}/read
activate Controller
Controller -> Service: markAsRead(msgId, userId)
activate Service

Service -> RepoMsg: findById(msgId)
RepoMsg -> DB: SELECT * FROM messages WHERE id = ?
DB --> RepoMsg: MessageEntity
RepoMsg --> Service: message

alt UÅ¼ytkownik jest odbiorcÄ…
    Service -> Service: message.setIsRead(true)
    Service -> RepoMsg: save(message)
    RepoMsg -> DB: UPDATE messages SET is_read = true
    DB --> RepoMsg: OK
    RepoMsg --> Service: updatedMessage
    Service --> Controller: MessageEntity
    deactivate Service
    Controller --> UI_B: 200 OK
    deactivate Controller
    UI_B -> UI_B: Usuwa oznaczenie "nieprzeczytane"
else UÅ¼ytkownik NIE jest odbiorcÄ…
    Service --> Controller: 403 Forbidden
    Controller --> UI_B: BÅ‚Ä…d
end

== Faza 6: Historia Konwersacji ==

Buyer -> UI_B: PrzeglÄ…da wiadomoÅ›ci
UI_B -> Controller: GET /api/messages/conversation/{convId}/messages
Controller -> Service: getConversationMessages(convId, userId)

Service -> RepoMsg: findByConversationId(convId)
RepoMsg -> DB: SELECT * FROM messages\nWHERE conversation_id = ?\nORDER BY timestamp ASC
DB --> RepoMsg: List<MessageEntity>
RepoMsg --> Service: messages

Service -> Service: Weryfikuje uprawnienia\n(czy user jest uczestnikiem)

alt UÅ¼ytkownik jest uczestnikiem
    Service --> Controller: List<MessageEntity>
    Controller --> UI_B: 200 OK [messages]
    UI_B -> Buyer: WyÅ›wietla caÅ‚Ä… historiÄ™
else UÅ¼ytkownik NIE jest uczestnikiem
    Service --> Controller: 403 Forbidden
    Controller --> UI_B: BÅ‚Ä…d
    UI_B -> Buyer: "Brak dostÄ™pu"
end



@enduml
