================================================================================
              OPIS DIAGRAM√ìW PRZEP≈ÅYWU STEROWANIA (SEQUENCE DIAGRAMS)
================================================================================

Data utworzenia: 25.01.2026
Wersja: 1.0

================================================================================
1. DIAGRAM: UTWORZENIE I PUBLIKACJA AUKCJI
   (Plik: 03_Sequence_Diagram_Utworzenie_Aukcji.puml)
================================================================================

SCENARIUSZ:
-----------
Sprzedawca loguje siƒô do systemu i tworzy nowƒÖ aukcjƒô sprzeda≈ºy samochodu,
przesy≈Ça zdjƒôcia, a nastƒôpnie publikuje og≈Çoszenie.

AKTORZY:
--------
‚Ä¢ Sprzedawca (Seller) - osoba sprzedajƒÖca samoch√≥d
‚Ä¢ System Otomotus - aplikacja backend

KOMPONENTY ZAANGA≈ªOWANE:
-------------------------
‚Ä¢ Frontend (Browser/UI) - interfejs u≈ºytkownika
‚Ä¢ API Gateway - punkt wej≈õcia REST API
‚Ä¢ JWT Filter - filtr autoryzacyjny
‚Ä¢ AuctionController - kontroler obs≈ÇugujƒÖcy ≈ºƒÖdania
‚Ä¢ AuctionService - logika biznesowa aukcji
‚Ä¢ AuctionRepository - dostƒôp do danych aukcji
‚Ä¢ UserRepository - dostƒôp do danych u≈ºytkownik√≥w
‚Ä¢ ImageStorageService - zarzƒÖdzanie plikami
‚Ä¢ Database - warstwa persystencji

FAZY PROCESU:
-------------

FAZA 1: AUTORYZACJA (Kroki 1-3)
--------------------------------
Cel: Uwierzytelnienie u≈ºytkownika i uzyskanie tokenu JWT

Przebieg:
1. Sprzedawca wprowadza dane logowania (username, password)
2. Frontend wysy≈Ça POST /api/auth/login
3. System weryfikuje dane i zwraca token JWT
4. Token jest zapisywany w localStorage przeglƒÖdarki

Token JWT zawiera:
‚Ä¢ Username (identyfikator u≈ºytkownika)
‚Ä¢ Role (USER/ADMIN)
‚Ä¢ Expiration time (czas wyga≈õniƒôcia, typowo 24h)

Mo≈ºliwe b≈Çƒôdy:
‚Ä¢ 401 Unauthorized - nieprawid≈Çowe dane logowania
‚Ä¢ 403 Forbidden - konto nieaktywne

FAZA 2: PRZYGOTOWANIE DANYCH (Kroki 4-5)
-----------------------------------------
Cel: Zebranie wszystkich wymaganych informacji o poje≈∫dzie

U≈ºytkownik wype≈Çnia formularz zawierajƒÖcy:

Dane pojazdu (CarEntity):
‚Ä¢ VIN (numer identyfikacyjny)
‚Ä¢ Marka, model, generacja
‚Ä¢ Rok produkcji
‚Ä¢ Przebieg (km)
‚Ä¢ Pojemno≈õƒá silnika (ccm)
‚Ä¢ Moc silnika (KM)
‚Ä¢ Rodzaj paliwa (PETROL/DIESEL/ELECTRIC/HYBRID)
‚Ä¢ Skrzynia bieg√≥w (MANUAL/AUTOMATIC)
‚Ä¢ Kolor

Dane aukcji (AuctionEntity):
‚Ä¢ Tytu≈Ç og≈Çoszenia
‚Ä¢ Opis (opcjonalny)
‚Ä¢ Cena (wymagana)
‚Ä¢ Lokalizacja
‚Ä¢ Czy cena negocjowana (boolean)
‚Ä¢ Numer telefonu

Walidacja:
Frontend wykonuje wstƒôpnƒÖ walidacjƒô (wymagane pola, format VIN, etc.)

FAZA 3: UPLOAD ZDJƒòƒÜ (Kroki 6-15)
----------------------------------
Cel: Przes≈Çanie i zapisanie zdjƒôƒá pojazdu

Proces dla ka≈ºdego zdjƒôcia:
1. U≈ºytkownik wybiera plik (JPG, PNG, max 10MB)
2. Frontend wysy≈Ça POST /api/auctions/{tempId}/images jako multipart/form-data
3. JWT Filter weryfikuje token
4. Controller przekazuje plik do ImageStorageService
5. Service generuje unikalnƒÖ nazwƒô: UUID_original_name.jpg
6. Plik zapisywany w katalogu: /uploads/
7. Tworzony rekord AuctionImageEntity w bazie
8. Frontend pokazuje miniaturƒô uploadowanego zdjƒôcia

Mo≈ºliwe b≈Çƒôdy:
‚Ä¢ 413 Payload Too Large - plik za du≈ºy
‚Ä¢ 415 Unsupported Media Type - nieprawid≈Çowy format
‚Ä¢ 401 Unauthorized - brak lub nieprawid≈Çowy token

Zabezpieczenia:
‚Ä¢ Walidacja typu MIME
‚Ä¢ Limit rozmiaru pliku
‚Ä¢ Sanityzacja nazwy pliku
‚Ä¢ Przypisanie do u≈ºytkownika

FAZA 4: UTWORZENIE AUKCJI (Kroki 16-35)
----------------------------------------
Cel: Zapisanie aukcji w bazie danych

Szczeg√≥≈Çowy przebieg:

1. Frontend wysy≈Ça POST /api/auctions z obiektem AuctionCreateRequestDto

2. API Gateway przekazuje request do JWT Filter

3. JWT Filter dekoduje i weryfikuje token:
   - Sprawdza podpis cyfrowy
   - Sprawdza expiration time
   - Ekstraktuje username i role

4. Je≈õli token nieprawid≈Çowy:
   ‚Üí 401 Unauthorized
   ‚Üí Frontend przekierowuje do logowania

5. Je≈õli token prawid≈Çowy:
   Request trafia do AuctionController.createAuction()

6. Controller deleguje do AuctionService

7. Service wyszukuje u≈ºytkownika:
   UserRepository.findByUsername(username)

8. Je≈õli u≈ºytkownik nie znaleziony:
   ‚Üí ResourceNotFoundException
   ‚Üí 404 Not Found

9. Service mapuje DTO na encje:
   - AuctionCreateRequestDto ‚Üí CarEntity
   - AuctionCreateRequestDto ‚Üí AuctionEntity

10. Service ustawia dodatkowe pola:
    ‚Ä¢ auction.setSeller(user) - powiƒÖzanie ze sprzedawcƒÖ
    ‚Ä¢ auction.setStatus(ACTIVE) - status aktywny
    ‚Ä¢ auction.setExpiresAt(LocalDateTime.now().plusDays(30)) - wygasa za 30 dni
    ‚Ä¢ auction.setViewCount(0) - licznik wy≈õwietle≈Ñ
    ‚Ä¢ auction.setPromoted(false) - nie promowane

11. Service zapisuje do bazy:
    AuctionRepository.save(auction)

12. Database wykonuje transakcjƒô:
    BEGIN TRANSACTION
    INSERT INTO cars (...) VALUES (...)
    INSERT INTO auctions (...) VALUES (...)
    COMMIT

13. Hibernate zwraca encjƒô z wygenerowanym ID (UUID)

14. Service mapuje AuctionEntity ‚Üí AuctionResponseDto

15. Controller zwraca 200 OK z DTO

16. Frontend pokazuje sukces i przekierowuje na stronƒô aukcji

Transakcyjno≈õƒá:
‚Ä¢ Ca≈Ça operacja odbywa siƒô w jednej transakcji (@Transactional)
‚Ä¢ Je≈õli kt√≥rykolwiek krok siƒô nie powiedzie, nastƒôpuje ROLLBACK
‚Ä¢ Dane Car i Auction sƒÖ zapisywane atomowo

FAZA 5: WERYFIKACJA (Kroki 36-45)
----------------------------------
Cel: Sprawdzenie poprawno≈õci utworzonej aukcji

1. Sprzedawca klika link do swojej aukcji
2. Frontend wysy≈Ça GET /api/auctions/{id}
3. System pobiera aukcjƒô z bazy
4. System inkrementuje licznik wy≈õwietle≈Ñ (viewCount++)
5. System dodaje statystyki sprzedawcy (liczba og≈Çosze≈Ñ)
6. Frontend wy≈õwietla pe≈Çne szczeg√≥≈Çy

Sprzedawca widzi:
‚Ä¢ Wszystkie dane pojazdu
‚Ä¢ Przes≈Çane zdjƒôcia
‚Ä¢ Liczbƒô wy≈õwietle≈Ñ = 1
‚Ä¢ Status: ACTIVE
‚Ä¢ Przyciski: "Edytuj", "Usu≈Ñ"

MECHANIZMY BEZPIECZE≈ÉSTWA:
--------------------------
1. Autoryzacja JWT na ka≈ºdym kroku
2. Walidacja danych wej≈õciowych (@Valid annotations)
3. Sprawdzanie uprawnie≈Ñ (czy user jest w≈Ça≈õcicielem)
4. Transakcje zapewniajƒÖce sp√≥jno≈õƒá danych
5. Hashowanie plik√≥w (UUID) zapobiega konfliktom

WYDAJNO≈öƒÜ:
----------
‚Ä¢ Lazy loading relacji (ManyToOne, OneToMany)
‚Ä¢ Eager loading tylko dla Car (potrzebne od razu)
‚Ä¢ Batch insert dla zdjƒôƒá
‚Ä¢ Indeksy na kolumnach: seller_id, status, created_at

================================================================================
2. DIAGRAM: KOMUNIKACJA MIƒòDZY U≈ªYTKOWNIKAMI (WebSocket)
   (Plik: 04_Sequence_Diagram_Komunikacja.puml)
================================================================================

SCENARIUSZ:
-----------
KupujƒÖcy kontaktuje siƒô ze sprzedawcƒÖ w sprawie aukcji. Wykorzystywana jest
technologia WebSocket dla komunikacji w czasie rzeczywistym.

AKTORZY:
--------
‚Ä¢ KupujƒÖcy (Buyer) - osoba zainteresowana zakupem
‚Ä¢ Sprzedawca (Seller) - w≈Ça≈õciciel aukcji

KOMPONENTY ZAANGA≈ªOWANE:
-------------------------
‚Ä¢ Browser (UI) - interfejs u≈ºytkownika dla obu stron
‚Ä¢ WebSocket Client - klient WS w przeglƒÖdarce
‚Ä¢ WebSocket Server - serwer STOMP/SockJS
‚Ä¢ ChatController - kontroler wiadomo≈õci
‚Ä¢ ChatService - logika biznesowa czatu
‚Ä¢ MessageRepository - przechowywanie wiadomo≈õci
‚Ä¢ ConversationRepository - przechowywanie konwersacji
‚Ä¢ UserRepository - dane u≈ºytkownik√≥w
‚Ä¢ Database - warstwa persystencji

FAZY PROCESU:
-------------

FAZA 1: INICJALIZACJA PO≈ÅƒÑCZENIA (Kroki 1-10)
----------------------------------------------
Cel: NawiƒÖzanie po≈ÇƒÖczenia WebSocket z serwerem

Przebieg dla KupujƒÖcego:
1. KupujƒÖcy otwiera stronƒô aukcji
2. Frontend pobiera dane aukcji przez REST API
3. Wy≈õwietlany jest przycisk "Kontakt ze sprzedawcƒÖ"
4. KupujƒÖcy klika przycisk
5. Frontend inicjuje po≈ÇƒÖczenie WebSocket:
   ws://localhost:8080/ws

6. Wysy≈Çany jest token JWT w headerze:
   Authorization: Bearer eyJhbGc...

7. WebSocket Server weryfikuje token:
   ‚Ä¢ Dekoduje JWT
   ‚Ä¢ Sprawdza wa≈ºno≈õƒá
   ‚Ä¢ Ekstraktuje userId

8. Je≈õli token prawid≈Çowy:
   ‚Üí Connection established
   ‚Üí U≈ºytkownik przypisany do sesji WS

9. Frontend otrzymuje potwierdzenie po≈ÇƒÖczenia

R√≥wnolegle - Sprzedawca:
Analogiczny proces dla Sprzedawcy, kt√≥ry mo≈ºe byƒá ju≈º zalogowany
lub loguje siƒô p√≥≈∫niej.

Protok√≥≈Ç WebSocket:
‚Ä¢ Upgrade z HTTP na WS
‚Ä¢ Persistent connection (nie zamyka siƒô po ka≈ºdym message)
‚Ä¢ Dwukierunkowa komunikacja (full-duplex)
‚Ä¢ Niskie op√≥≈∫nienia (<100ms)

FAZA 2: WYS≈ÅANIE PIERWSZEJ WIADOMO≈öCI (Kroki 11-30)
----------------------------------------------------
Cel: Utworzenie konwersacji i wys≈Çanie pierwszego komunikatu

1. KupujƒÖcy pisze wiadomo≈õƒá w formularzu:
   "Czy auto jest dostƒôpne?"

2. Frontend wysy≈Ça REST request:
   POST /api/messages/send
   Body: {
     recipientId: "uuid-sprzedawcy",
     productId: "uuid-aukcji",
     content: "Czy auto jest dostƒôpne?"
   }

3. ChatController odbiera request

4. ChatService.sendMessage() wykonuje:

   a) Weryfikacja nadawcy:
      UserRepository.findById(senderId)

   b) Weryfikacja odbiorcy:
      UserRepository.findById(recipientId)

   c) Sprawdzenie konwersacji:
      ConversationRepository.findConversationBetweenUsers(
        senderId, recipientId, productId
      )

      Je≈õli konwersacja NIE istnieje:
      ‚Üí Tworzy nowƒÖ ConversationEntity:
         - participant1 = kupujƒÖcy
         - participant2 = sprzedawca
         - auction = aukcja
         - createdAt = now()
      ‚Üí Zapisuje w bazie

   d) Utworzenie wiadomo≈õci:
      MessageEntity:
      - conversation = conversation
      - sender = kupujƒÖcy
      - recipient = sprzedawca
      - content = "Czy auto jest dostƒôpne?"
      - timestamp = now()
      - isRead = false
      - isEdited = false

   e) Zapis do bazy:
      MessageRepository.save(message)
      Database wykonuje:
      INSERT INTO messages (...) VALUES (...)

5. Service zwraca zapisanƒÖ MessageEntity

6. Controller zwraca 200 OK z obiektem message

7. Frontend dodaje wiadomo≈õƒá do UI (bez od≈õwie≈ºania)

Struktura ConversationEntity:
‚Ä¢ id (UUID)
‚Ä¢ participant1 (UserEntity)
‚Ä¢ participant2 (UserEntity)
‚Ä¢ auction (AuctionEntity) - kontekst rozmowy
‚Ä¢ lastMessageAt (timestamp ostatniej wiadomo≈õci)
‚Ä¢ createdAt

Struktura MessageEntity:
‚Ä¢ id (UUID)
‚Ä¢ conversation (ConversationEntity)
‚Ä¢ sender (UserEntity)
‚Ä¢ recipient (UserEntity)
‚Ä¢ content (TEXT)
‚Ä¢ timestamp (LocalDateTime)
‚Ä¢ isRead (boolean)
‚Ä¢ isEdited (boolean)

FAZA 3: WYSY≈ÅKA PRZEZ WEBSOCKET (Kroki 31-37)
----------------------------------------------
Cel: Dostarczenie wiadomo≈õci w czasie rzeczywistym

1. Frontend kupujƒÖcego po otrzymaniu 200 OK
   wysy≈Ça wiadomo≈õƒá przez WebSocket:

   wsClient.send("/app/chat.send", {
     messageId: "uuid-wiadomo≈õci",
     recipientId: "uuid-sprzedawcy"
   })

2. WebSocket Server odbiera wiadomo≈õƒá

3. Server identyfikuje odbiorcƒô (recipientId)

4. Server sprawdza czy sprzedawca jest online (aktywna sesja WS)

5. Je≈õli sprzedawca ONLINE:
   Server wysy≈Ça broadcast do jego sesji:

   SEND /topic/messages/{sellerId}
   Body: {
     messageId: "uuid",
     senderId: "uuid-kupujƒÖcego",
     senderName: "Jan Kowalski",
     content: "Czy auto jest dostƒôpne?",
     timestamp: "2026-01-25T12:30:00"
   }

6. WebSocket Client sprzedawcy odbiera wiadomo≈õƒá

7. Frontend sprzedawcy:
   ‚Ä¢ Wy≈õwietla powiadomienie
   ‚Ä¢ Odtwarza d≈∫wiƒôk (opcjonalnie)
   ‚Ä¢ Pokazuje badge z liczbƒÖ nieprzeczytanych
   ‚Ä¢ Aktualizuje listƒô konwersacji

8. Sprzedawca widzi:
   üîî "Nowa wiadomo≈õƒá od Jan Kowalski"

Je≈õli sprzedawca OFFLINE:
‚Ä¢ Wiadomo≈õƒá czeka w bazie
‚Ä¢ Zostanie pobrana przy nastƒôpnym logowaniu
‚Ä¢ Opcjonalnie: wys≈Çanie email notification

FAZA 4: ODPOWIED≈π SPRZEDAWCY (Kroki 38-48)
-------------------------------------------
Cel: Dwukierunkowa komunikacja

1. Sprzedawca pisze odpowied≈∫:
   "Tak, auto dostƒôpne. Tel: 123-456-789"

2. Proces analogiczny jak w Fazie 2-3:
   ‚Ä¢ POST /api/messages/send
   ‚Ä¢ Zapis w bazie
   ‚Ä¢ Wysy≈Çka przez WebSocket

3. KupujƒÖcy odbiera wiadomo≈õƒá w czasie rzeczywistym

4. Frontend kupujƒÖcego wy≈õwietla:
   üîî "Nowa odpowied≈∫ od Adam Nowak"

Optymalizacje:
‚Ä¢ Message nie jest duplikowane w bazie
‚Ä¢ WebSocket u≈ºywany tylko do notyfikacji
‚Ä¢ Pe≈Çne dane pobierane przez REST w razie potrzeby

FAZA 5: OZNACZENIE JAKO PRZECZYTANE (Kroki 49-60)
--------------------------------------------------
Cel: Tracking statusu wiadomo≈õci

1. KupujƒÖcy otwiera rozmowƒô (lista wiadomo≈õci)

2. Frontend automatycznie wysy≈Ça dla ka≈ºdej nieprzeczytanej:
   PATCH /api/messages/{messageId}/read

3. ChatController.markAsRead(messageId, userId)

4. ChatService weryfikuje:
   ‚Ä¢ Czy wiadomo≈õƒá istnieje
   ‚Ä¢ Czy userId = recipient.id (tylko odbiorca mo≈ºe oznaczyƒá)

5. Je≈õli OK:
   message.setIsRead(true)
   MessageRepository.save(message)
   Database: UPDATE messages SET is_read = true WHERE id = ?

6. Zwrot 200 OK

7. Frontend usuwa oznaczenie "nieprzeczytane" (‚óè)

8. Opcjonalnie: WebSocket notyfikacja do nadawcy
   "Twoja wiadomo≈õƒá zosta≈Ça przeczytana" (‚úì‚úì)

Status wiadomo≈õci (jak w WhatsApp):
‚Ä¢ ‚úì - wys≈Çana (saved in DB)
‚Ä¢ ‚úì‚úì - dostarczona (recipient fetched)
‚Ä¢ ‚úì‚úì (niebieskie) - przeczytana (isRead = true)

FAZA 6: HISTORIA KONWERSACJI (Kroki 61-72)
-------------------------------------------
Cel: Dostƒôp do pe≈Çnej historii rozmowy

1. U≈ºytkownik przeglƒÖda wiadomo≈õci

2. Frontend wysy≈Ça:
   GET /api/messages/conversation/{conversationId}/messages

3. ChatService.getConversationMessages(convId, userId)

4. Service pobiera:
   MessageRepository.findByConversationId(convId)
   ORDER BY timestamp ASC

5. Service weryfikuje uprawnienia:
   Czy userId jest participant1 lub participant2 konwersacji?

6. Je≈õli NIE:
   ‚Üí 403 Forbidden
   ‚Üí "Brak dostƒôpu do tej konwersacji"

7. Je≈õli TAK:
   ‚Üí 200 OK [List<MessageEntity>]

8. Frontend renderuje chronologicznƒÖ listƒô wiadomo≈õci:
   ‚Ä¢ Wiadomo≈õci w≈Çasne po prawej
   ‚Ä¢ Wiadomo≈õci partnera po lewej
   ‚Ä¢ Timestamps
   ‚Ä¢ Statusy przeczytania

Paginacja (dla wydajno≈õci):
‚Ä¢ Domy≈õlnie: ostatnie 50 wiadomo≈õci
‚Ä¢ "Load more" ≈Çaduje starsze w partiach po 50
‚Ä¢ Scroll do g√≥ry = automatyczne ≈Çadowanie

MECHANIZMY BEZPIECZE≈ÉSTWA:
--------------------------
1. JWT Token w WebSocket handshake
2. Autoryzacja na poziomie konwersacji (tylko uczestnicy)
3. Walidacja recipientId (zapobiega spoofing)
4. XSS protection (sanityzacja HTML w content)
5. Rate limiting (max 10 msg/min na u≈ºytkownika)
6. Timeout dla nieaktywnych sesji WS (30 min)

OBS≈ÅUGA B≈ÅƒòD√ìW:
---------------
‚Ä¢ Utrata po≈ÇƒÖczenia WS: automatyczne reconnect
‚Ä¢ Wiadomo≈õƒá niezapisana: retry mechanism
‚Ä¢ Odbiorca offline: queue w bazie + email
‚Ä¢ Konflikt edycji: last-write-wins

WYDAJNO≈öƒÜ:
----------
‚Ä¢ WebSocket: sta≈Çe po≈ÇƒÖczenie, brak overhead HTTP
‚Ä¢ Indeksy: conversation_id, sender_id, timestamp
‚Ä¢ Lazy loading starszych wiadomo≈õci
‚Ä¢ Redis cache dla online users (opcjonalnie)

PRZYSZ≈ÅE ROZSZERZENIA:
----------------------
‚Ä¢ Typing indicators ("U≈ºytkownik pisze...")
‚Ä¢ Reakcje emoji na wiadomo≈õci
‚Ä¢ Za≈ÇƒÖczniki (zdjƒôcia, dokumenty)
‚Ä¢ Grupowe rozmowy (wiƒôcej ni≈º 2 osoby)
‚Ä¢ Video/audio calls

================================================================================
KONIEC DOKUMENTU
================================================================================
